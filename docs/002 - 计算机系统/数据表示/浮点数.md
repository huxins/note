# 浮点数

## 一、数值表示

### 定点数与浮点数

- 定点数：小数点位置固定
- 浮点数：小数点位置浮动（科学计数法表示）

### 进制转换方法

- **二进制转十进制**：加权系数展开式
- **十进制整数转二进制**：除 2 取余法
- **十进制小数转二进制**：乘 2 取整法

## 二、定点数

定点表示法是一种计算机数值存储方式，其核心特征在于预先固定小数点的位置。该方法将数值拆分为整数部分和小数部分分别进行二进制转换，通过二进制拼接实现数据存储，采用这种表示形式的数值称为定点数。

- **纯整数**：小数点固定最低位（示例：100 → 01100100）
- **纯小数**：小数点固定最高位（示例：0.125 → 0.00100000）
- **混合表示**：自定义整数/小数位分配（示例：1.5 → 00001.100）

纯整数与纯小数作为定点数的两种特例，基于小数点固定于数值最低位或最高位的特性，其数值编码原理具有一致性，通过独立转换整数与小数部分至二进制即可实现定点表示。

**纯整数**：

```
100 = 01100100
```

**纯小数**：

```
0.125 = 0.00100000
```

定点表示法处理复合数值时需预先设定小数点基准位，通过对整数与小数部分执行分段二进制转换实现机器数表征。

**混合表示**：以单个字节为例，我们可以约定前 5 位表示整数部分，后 3 位表示小数部分。

```
1.5 = 00001 100
25.125 = 11001 001
```

定点数系统的数值扩展路径包含两种机制：

- **位宽扩容**：同步扩展整数与小数域位宽，提升整体数值容量
- **基准位偏移**：右移小数点基准位以扩展整数域，但伴随小数位精度衰减

该数值编码系统中，表示范围与精度参数呈现负相关约束。

## 三、浮点数

浮点数的命名源于其小数点的动态定位特性，该数值表示法的基准位可根据指数参数进行自适应偏移。

### 科学计数法

- 通用公式：`V = (-1)^S * M * R^E`
- 二进制实现：基数 R=2，尾数 M 规范化处理

例如，十进制小数 8.345，用科学计数法表示，可以有多种方式：

```
8.345 = 8.345 * 10^0
8.345 = 83.45 * 10^-1
8.345 = 834.5 * 10^-2
...
```

使用同样的规则，对于二进制数，也可以用科学计数法表示，把基数 10 换成 2 即可。

其中各个变量的含义如下：

- **S**：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负
- **M**：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数
- **R**：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2
- **E**：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数

### IEEE 754

#### 数据格式定义

| 精度类型   | 总位数 | 结构分解                      | 指数偏移量 |
| ---------- | ------ | ----------------------------- | ---------- |
| 单精度浮点 | 32-bit | 1符号位 + 8指数位 + 23尾数位  | +127       |
| 双精度浮点 | 64-bit | 1符号位 + 11指数位 + 52尾数位 | +1023      |

**指数-尾数动态平衡**：指数位与尾数位的位数分配呈反相关，指数位增加可扩展数值表示范围但降低精度，尾数位增加则提升精度但缩小表示范围。不同格式的计算结果在范围与精度上存在系统性差异。

#### 核心实现机制

- **隐含最高位（Hidden Bit）**
  - 规格化数通过位移操作强制尾数最高有效位为 1，该位不显式存储
  - 有效位数扩展：单精度实现 24 位（23+1），双精度实现 53 位（52+1）
- **指数偏置编码（Exponent Bias）**
  - 指数采用无符号整型存储，通过固定偏移实现正负指数表示
  - 实际指数计算：E = 存储值 - 偏移量
  - 动态范围：
    - 单精度：-126 ~ +127（存储值 1 ~ 254）
    - 双精度：-1022 ~ +1023（存储值 1 ~ 2046）
- **特殊数值编码规范**
  
  | 类别        | 指数域    | 尾数域 | 语义定义                          |
  | ----------- | --------- | ------ | --------------------------------- |
  | 规格化数    | 非全0/全1 | 任意值 | 标准浮点数值                      |
  | 非规格化数  | 全0       | 非全0  | 零及次正规数，隐含位0，指数偏置-1 |
  | 无穷大      | 全1       | 全0    | ±INF                              |
  | 非数值(NaN) | 全1       | 非全0  | 非法操作结果                      |
  
- **非规格化数特殊处理**：
  - 单精度指数等效值：-126（原偏移 127，现采用 126）
  - 双精度指数等效值：-1022（原偏移 1023，现采用 1022）
  - 实现从零到最小规格化数的平滑过渡，增强数值连续性

### 精度问题

- 十进制小数转二进制的截断现象
- 单双精度有效位数：7 位和 15 位十进制精度

由于十进制小数存在二进制表示约束，在有限精度数值表示体系下必然产生精度损失。

计算机受限于有限位宽存储机制，当转换不可通约十进制小数（如 0.1）时，其二进制展开形式为无限循环小数，在存储过程中发生强制截断，形成系统性的尾数截断误差，此即浮点运算精度问题的本质成因。

例如，`0.2` 转换为二进制数的过程为：

```
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0
...
```

- 单精度浮点数

  `1<<23` 对应十进制是 8388608，因此不能完整表示全部的 7 个十进制位，所以，单精度浮点数有效小数位最多 7 位。

- 双精度浮点数

  `1<<52` 对应十进制是 4503599627370496，因此有效小数位是 15 位。

## Reference

- [0.30000000000000004.com](https://0.30000000000000004.com/)
- [什么是浮点数 - *知乎*](https://zhuanlan.zhihu.com/p/339949186)
- [15 张图带你深入理解浮点数](https://polarisxu.studygolang.com/posts/basic/diagram-float-point/)
- [JavaScript 中 0.1 + 0.2](https://www.explainthis.io/zh-hans/swe/js-zero-point-one-plus-zero-point-two)

