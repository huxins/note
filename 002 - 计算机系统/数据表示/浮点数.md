# 浮点数

## 一、数值表示

### 定点数与浮点数

- 定点数：小数点位置固定
- 浮点数：小数点位置浮动（科学计数法表示）

### 进制转换方法

- **二进制转十进制**：加权系数展开式
- **十进制整数转二进制**：除 2 取余法
- **十进制小数转二进制**：乘 2 取整法

## 二、定点数

### 表示规则

定点表示法是一种计算机数值存储方式，其核心特征在于预先固定小数点的位置。该方法将数值拆分为整数部分和小数部分分别进行二进制转换，通过二进制拼接实现数据存储，采用这种表示形式的数值称为定点数。

- **纯整数**：小数点固定最低位（示例：100 → 01100100）
- **纯小数**：小数点固定最高位（示例：0.125 → 0.00100000）
- **混合表示**：自定义整数/小数位分配（示例：1.5 → 00001.100）

纯整数与纯小数作为定点数的两种特例，基于小数点固定于数值最低位或最高位的特性，其数值编码原理具有一致性，通过独立转换整数与小数部分至二进制即可实现定点表示。

**纯整数**：

```
100 = 01100100
```

**纯小数**：

```
0.125 = 0.00100000
```

定点表示法处理复合数值时需预先设定小数点基准位，通过对整数与小数部分执行分段二进制转换实现机器数表征。

**混合表示**：以单个字节为例，我们可以约定前 5 位表示整数部分，后 3 位表示小数部分。

```
1.5 = 00001 100
25.125 = 11001 001
```

基于定点数，想要表示更大范围的值，可以通过两种方式：

- 扩大 bit 的宽度，这样整数部分和小数部分宽度增加，表示范围也就变大了
- 改变小数点的位置，小数点向后移动，整数范围就会扩大，但是小数部分的精度就会越来越低

但定点数的**表示范围**和**精度范围**难两全。

## 浮点数

顾名思义，浮点数是指数值的小数点位置是漂浮不定的。

浮点数是采用科学计数法的方式来表示的，例如十进制小数 8.345，用科学计数法表示，可以有多种方式：

```
8.345 = 8.345 * 10^0
8.345 = 83.45 * 10^-1
8.345 = 834.5 * 10^-2
...
```

使用同样的规则，对于二进制数，也可以用科学计数法表示，把基数 10 换成 2 即可。

### 浮点数格式

它的格式可以写成这样：

```
V = (-1)^S * M * R^E
```

其中各个变量的含义如下：

- S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负
- M：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数
- R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2
- E：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数

如果我们要在计算机中，用浮点数表示一个数字，只需要确认这几个变量即可。

指数和尾数分配的位数不同，会产生以下情况：

- 指数位越多，尾数位则越少，其表示的范围越大，但精度就会变差，反之类似
- 会因为定义的浮点数格式规则不同，得到的结果也不同，表示的范围和精度也有差异

### 浮点数标准

1985 年，IEEE 组织推出了浮点数标准，**IEEE754** 浮点数标准，这个标准统一了浮点数的表示形式，并提供了 2 种浮点格式：

- 单精度浮点数 float：32 位，符号位 S 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit
- 双精度浮点数 double：64 位，符号位 S 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit

为了使其表示的数字范围、精度最大化，浮点数标准还对指数和尾数进行了规定：

- 通过移位，将尾数 M 的首位固定为 1，因此这个 1 可以省略不写，它是个**隐藏位**，这样单精度 23 位尾数可以表示 24 位有效数字，双精度 52 位尾数可以表示 53 位有效数字
- 指数 E 是个无符号整数。表示 float 时，它的取值范围为 0 ~ 255，但因为指数可以是负的，所以规定在存入 E 时在它原本的值加上一个**中间数** 127，这样 E 的取值范围为 -127 ~ 128；表示 double 时，存入 E 时加上中间数 1023，这样取值范围为 -1023 ~ 1024。

除了规定尾数和指数位，还做了以下规定：

- 指数 E 非全 0 且非全 1：规格化数，按上面的规则正常计算
- 指数 E 全 0，尾数非 0：非规格化数，尾数隐藏位不再是 1，而是 0，同时指数部分的偏移值比规范形式的偏移值小 1，即单精度是 -126，双精度是 -2046。这样可以表示 0 和很小的数，和规格化数互补。
- 指数 E 全 1，尾数全 0：正无穷大/负无穷大
- 指数 E 全 1，尾数非 0：NaN

### 精度损失

十进制小数无法精确转换成二进制小数，而计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。

例如 0.2 转换为二进制数的过程为：

```
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0
...
```

### 浮点数精度

- 单精度浮点数 float

`1<<23` 对应十进制是 8388608，因此不能完整表示全部的 7 个十进制位，所以，单精度浮点数**有效小数位**最多 7 位。

- 双精度浮点数 double

`1<<52` 对应十进制是 4503599627370496，因此**有效小数位**是 15 位。


## 进制转换

- **二进制数转换成十进制数**

由二进制数转换成十进制数的基本做法是，把二进制数写成加权系数展开式，然后按十进制加法规则求和。这种做法称为*按权相加*法。

例如：把二进制数 110.11 转换成十进制数：

110.11 = (1 * 2<sup>2</sup>) + (1 * 2<sup>1</sup>) + (0 * 2<sup>0</sup>) + (1 * 2<sup>-1</sup>) + (1 * 2<sup>-2</sup>) = 6.75

- **十进制数转换成二进制数，整数部分**

采用*除 2 取余，逆序排列*法。用 2 去除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

- **十进制数转换成二进制数，小数部分**

采用*乘 2 取整，顺序排列*法。用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。

## Reference

- [0.30000000000000004.com](https://0.30000000000000004.com/)
- [什么是浮点数 - *知乎*](https://zhuanlan.zhihu.com/p/339949186)
- [15 张图带你深入理解浮点数](https://polarisxu.studygolang.com/posts/basic/diagram-float-point/)

