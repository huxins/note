# 浮点数

## 定点数

数字既包括整数，又包括小数，而小数的精度范围要比整数大得多，所以如果我们想在计算机中，既能表示整数，也能表示小数，关键就在于这个小数点如何表示。

约定计算机中小数点的位置，且这个位置固定不变，小数点前、后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中存储起来，这种表示方式叫做定点表示法，用这种方法表示的数字叫做定点数。

定点数如果要表示整数或小数，分为以下三种情况：

- **纯整数**：例如整数 100，小数点在最后一位。
- **纯小数**：例如小数 0.123，小数点固定在最高位。
- **整数和小数**：例如 1.24、10.34，小数点指定在某个位置。

对于前两种情况，纯整数和纯小数，因为小数点固定在最低位和最高位，所以它们用定点数表示时，原理是相同的，只需要把整数部分、小数部分，按照十进制转二进制的规则，分别转换即可。

**纯整数：**

```
100 = 01100100
```

**纯小数：**

```
0.125 = 0.00100000
```

而对于整数和小数的情况，用定点表示时，需要约定小数点的位置，才能在计算机中表示。

**以 1 个字节为例，我们可以约定前 5 位表示整数部分，后 3 位表示小数部分：**

```
1.5 = 00001 100
25.125 = 11001 001
```

基于定点数，想要**表示更大范围的值**，可以通过两种方式：

- 扩大 bit 的宽度，这样整数部分和小数部分宽度增加，表示范围也就变大了
- 改变小数点的位置，小数点向后移动，整数范围就会扩大，但是小数部分的精度就会越来越低

但定点数的**表示范围**和**精度范围**难两全。

## 浮点数

顾名思义，浮点数是指数值的小数点位置是漂浮不定的。

浮点数是采用科学计数法的方式来表示的，例如十进制小数 8.345，用科学计数法表示，可以有多种方式：

```
8.345 = 8.345 * 10^0
8.345 = 83.45 * 10^-1
8.345 = 834.5 * 10^-2
...
```

使用同样的规则，对于二进制数，也可以用科学计数法表示，把基数 10 换成 2 即可。

### 浮点数格式

它的格式可以写成这样：

```
V = (-1)^S * M * R^E
```

其中各个变量的含义如下：

- S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负
- M：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数
- R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2
- E：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数

如果我们要在计算机中，用浮点数表示一个数字，只需要确认这几个变量即可。

指数和尾数分配的位数不同，会产生以下情况：

- 指数位越多，尾数位则越少，其表示的范围越大，但精度就会变差，反之类似
- 会因为定义的浮点数格式规则不同，得到的结果也不同，表示的范围和精度也有差异

### 浮点数标准

1985 年，IEEE 组织推出了浮点数标准，**IEEE754** 浮点数标准，这个标准统一了浮点数的表示形式，并提供了 2 种浮点格式：

- 单精度浮点数 float：32 位，符号位 S 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit
- 双精度浮点数 double：64 位，符号位 S 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit

为了使其表示的数字范围、精度最大化，浮点数标准还对指数和尾数进行了规定：

- 通过移位，将尾数 M 的首位固定为 1，因此这个 1 可以省略不写，它是个**隐藏位**，这样单精度 23 位尾数可以表示 24 位有效数字，双精度 52 位尾数可以表示 53 位有效数字
- 指数 E 是个无符号整数。表示 float 时，它的取值范围为 0 ~ 255，但因为指数可以是负的，所以规定在存入 E 时在它原本的值加上一个**中间数** 127，这样 E 的取值范围为 -127 ~ 128；表示 double 时，存入 E 时加上中间数 1023，这样取值范围为 -1023 ~ 1024。

除了规定尾数和指数位，还做了以下规定：

- 指数 E 非全 0 且非全 1：规格化数，按上面的规则正常计算
- 指数 E 全 0，尾数非 0：非规格化数，尾数隐藏位不再是 1，而是 0，同时指数部分的偏移值比规范形式的偏移值小 1，即单精度是 -126，双精度是 -2046。这样可以表示 0 和很小的数，和规格化数互补。
- 指数 E 全 1，尾数全 0：正无穷大/负无穷大
- 指数 E 全 1，尾数非 0：NaN

### 精度损失

十进制小数无法精确转换成二进制小数，而计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。

例如 0.2 转换为二进制数的过程为：

```
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0
...
```

### 浮点数精度

- 单精度浮点数 float

`1<<23` 对应十进制是 8388608，因此不能完整表示全部的 7 个十进制位，所以，单精度浮点数**有效小数位**最多 7 位。

- 双精度浮点数 double

`1<<52` 对应十进制是 4503599627370496，因此**有效小数位**是 15 位。


## 进制转换

- **二进制数转换成十进制数**

由二进制数转换成十进制数的基本做法是，把二进制数写成加权系数展开式，然后按十进制加法规则求和。这种做法称为*按权相加*法。

例如：把二进制数 110.11 转换成十进制数：

110.11 = (1 * 2<sup>2</sup>) + (1 * 2<sup>1</sup>) + (0 * 2<sup>0</sup>) + (1 * 2<sup>-1</sup>) + (1 * 2<sup>-2</sup>) = 6.75

- **十进制数转换成二进制数，整数部分**

采用*除 2 取余，逆序排列*法。用 2 去除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

- **十进制数转换成二进制数，小数部分**

采用*乘 2 取整，顺序排列*法。用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。

## Reference

- [0.30000000000000004.com](https://0.30000000000000004.com/)
- [什么是浮点数 - *知乎*](https://zhuanlan.zhihu.com/p/339949186)
- [15 张图带你深入理解浮点数](https://polarisxu.studygolang.com/posts/basic/diagram-float-point/)

